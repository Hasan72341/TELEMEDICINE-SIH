import React, { useState, useEffect, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import MotionWrapper from '../../components/MotionWrapper/MotionWrapper';
import doctorsData from '../../data/doctors.json';
import "./VideoCall.css";

const VideoCall = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const chatScrollRef = useRef(null);
  
  const [userPrefs, setUserPrefs] = useState(null);
  const [callStatus, setCallStatus] = useState('connecting'); // connecting, connected, ended
  const [isVideoOn, setIsVideoOn] = useState(true);
  const [isAudioOn, setIsAudioOn] = useState(true);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [callDuration, setCallDuration] = useState(0);
  const [chatMessages, setChatMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [showNotes, setShowNotes] = useState(false);
  const [consultationNotes, setConsultationNotes] = useState('');
  const [selectedDoctor, setSelectedDoctor] = useState(null);
  const [connectionQuality, setConnectionQuality] = useState('excellent');
  const [showEndConfirm, setShowEndConfirm] = useState(false);

  // Simulated consultation data
  const consultationInfo = {
    appointmentId: 'APPT_2025_001',
    patientName: '‡§∞‡§æ‡§π‡•Å‡§≤ ‡§∂‡§∞‡•ç‡§Æ‡§æ',
    consultationType: 'General Checkup',
    scheduledTime: '2:30 PM',
    symptoms: ['‡§¨‡•Å‡§ñ‡§æ‡§∞', '‡§∏‡§ø‡§∞‡§¶‡§∞‡•ç‡§¶', '‡§ñ‡§æ‡§Ç‡§∏‡•Ä']
  };

  useEffect(() => {
    // Load user preferences
    const prefs = JSON.parse(localStorage.getItem('userPreferences') || '{}');
    setUserPrefs(prefs);

    // Get doctor info from location state or default
    const doctorId = location.state?.doctorId || 'dr_sharma';
    const doctor = doctorsData.doctors.find(d => d.id === doctorId);
    setSelectedDoctor(doctor);

    // Initialize simulated video call
    initializeVideoCall();

    // Start call timer
    const timer = setInterval(() => {
      setCallDuration(prev => prev + 1);
    }, 1000);

    // Simulate connection status changes
    setTimeout(() => setCallStatus('connected'), 3000);

    // Add initial chat messages
    setTimeout(() => {
      addSystemMessage('‡§°‡•â‡§ï‡•ç‡§ü‡§∞ ‡§ï‡•â‡§≤ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã ‡§ó‡§è ‡§π‡•à‡§Ç');
      setTimeout(() => {
        addDoctorMessage('‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§°‡•â. ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§ú ‡§Ü‡§™‡§ï‡•Ä ‡§§‡§¨‡•Ä‡§Ø‡§§ ‡§ï‡•à‡§∏‡•Ä ‡§π‡•à?');
      }, 2000);
    }, 4000);

    return () => {
      clearInterval(timer);
      cleanupVideoCall();
    };
  }, []);

  const initializeVideoCall = async () => {
    try {
      // Simulate getting user media
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: true, 
        audio: true 
      });
      
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = stream;
      }

      // Simulate doctor's video (placeholder)
      setTimeout(() => {
        if (remoteVideoRef.current) {
          // Create a colored canvas as placeholder for doctor video
          const canvas = document.createElement('canvas');
          canvas.width = 640;
          canvas.height = 480;
          const ctx = canvas.getContext('2d');
          
          // Create gradient background
          const gradient = ctx.createLinearGradient(0, 0, 640, 480);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(1, '#764ba2');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 640, 480);
          
          // Add doctor icon
          ctx.font = '120px serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = 'white';
          ctx.fillText('üë®‚Äç‚öïÔ∏è', 320, 280);
          
          const stream = canvas.captureStream();
          remoteVideoRef.current.srcObject = stream;
        }
      }, 2000);

    } catch (error) {
      console.log('Simulated video call - camera access simulated');
      // Create placeholder for local video
      simulateLocalVideo();
    }
  };

  const simulateLocalVideo = () => {
    if (localVideoRef.current) {
      const canvas = document.createElement('canvas');
      canvas.width = 320;
      canvas.height = 240;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, 320, 240);
      ctx.font = '60px serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#666';
      ctx.fillText('üë§', 160, 150);
      
      const stream = canvas.captureStream();
      localVideoRef.current.srcObject = stream;
    }
  };

  const cleanupVideoCall = () => {
    if (localVideoRef.current && localVideoRef.current.srcObject) {
      const tracks = localVideoRef.current.srcObject.getTracks();
      tracks.forEach(track => track.stop());
    }
  };

  const addSystemMessage = (message) => {
    setChatMessages(prev => [...prev, {
      id: Date.now(),
      type: 'system',
      text: message,
      timestamp: new Date().toLocaleTimeString()
    }]);
  };

  const addDoctorMessage = (message) => {
    setChatMessages(prev => [...prev, {
      id: Date.now(),
      type: 'doctor',
      text: message,
      timestamp: new Date().toLocaleTimeString(),
      sender: selectedDoctor?.name || 'Doctor'
    }]);
  };

  const addPatientMessage = (message) => {
    setChatMessages(prev => [...prev, {
      id: Date.now(),
      type: 'patient',
      text: message,
      timestamp: new Date().toLocaleTimeString(),
      sender: consultationInfo.patientName
    }]);
  };

  const toggleVideo = () => {
    setIsVideoOn(!isVideoOn);
    if (localVideoRef.current && localVideoRef.current.srcObject) {
      const videoTrack = localVideoRef.current.srcObject.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !isVideoOn;
      }
    }
  };

  const toggleAudio = () => {
    setIsAudioOn(!isAudioOn);
    if (localVideoRef.current && localVideoRef.current.srcObject) {
      const audioTrack = localVideoRef.current.srcObject.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !isAudioOn;
      }
    }
  };

  const toggleScreenShare = () => {
    setIsScreenSharing(!isScreenSharing);
    addSystemMessage(isScreenSharing ? '‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§∂‡•á‡§Ø‡§∞‡§ø‡§Ç‡§ó ‡§¨‡§Ç‡§¶ ‡§ï‡•Ä ‡§ó‡§à' : '‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§∂‡•á‡§Ø‡§∞‡§ø‡§Ç‡§ó ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä ‡§ó‡§à');
  };

  const sendMessage = () => {
    if (newMessage.trim()) {
      addPatientMessage(newMessage);
      setNewMessage('');
      
      // Simulate doctor response
      setTimeout(() => {
        const responses = [
          '‡§∏‡§Æ‡§ù ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§î‡§∞ ‡§¨‡§§‡§æ‡§è‡§Ç‡•§',
          '‡§Ø‡§π ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§π‡•à‡•§',
          '‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™‡§ï‡•ã ‡§ï‡•ã‡§à ‡§î‡§∞ ‡§≤‡§ï‡•ç‡§∑‡§£ ‡§π‡•à‡§Ç?',
          '‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ú‡§æ‡§Ç‡§ö ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§'
        ];
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        addDoctorMessage(randomResponse);
      }, 2000);
    }
  };

  const endCall = () => {
    setShowEndConfirm(true);
  };

  const confirmEndCall = () => {
    setCallStatus('ended');
    cleanupVideoCall();
    
    // Generate consultation summary
    const summary = {
      doctorName: selectedDoctor?.name,
      duration: formatDuration(callDuration),
      notes: consultationNotes,
      prescription: '‡§™‡•á‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 500mg ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§¶‡•ã ‡§¨‡§æ‡§∞\n‡§Ü‡§∞‡§æ‡§Æ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§§‡§∞‡§≤ ‡§™‡§¶‡§æ‡§∞‡•ç‡§• ‡§≤‡•á‡§Ç',
      followUp: '3 ‡§¶‡§ø‡§® ‡§¨‡§æ‡§¶ ‡§´‡•â‡§≤‡•ã-‡§Ö‡§™'
    };
    
    localStorage.setItem('lastConsultationSummary', JSON.stringify(summary));
    
    setTimeout(() => {
      navigate('/consultation-summary', { state: { summary } });
    }, 2000);
  };

  const formatDuration = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getConnectionIcon = () => {
    switch (connectionQuality) {
      case 'excellent': return 'üì∂';
      case 'good': return 'üì∂';
      case 'poor': return 'üì∂';
      default: return 'üì∂';
    }
  };

  useEffect(() => {
    if (chatScrollRef.current) {
      chatScrollRef.current.scrollTop = chatScrollRef.current.scrollHeight;
    }
  }, [chatMessages]);

  if (callStatus === 'ended') {
    return (
      <MotionWrapper>
        <div className="video-call-container call-ended">
          <div className="call-ended-screen">
            <div className="call-ended-icon">üìû</div>
            <h2>‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ó‡§à</h2>
            <p>‡§™‡§∞‡§æ‡§Æ‡§∞‡•ç‡§∂ ‡§ï‡•Ä ‡§Ö‡§µ‡§ß‡§ø: {formatDuration(callDuration)}</p>
            <p>‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡•Ä ‡§ú‡§æ ‡§∞‡§π‡•Ä ‡§π‡•à...</p>
            <div className="loading-spinner"></div>
          </div>
        </div>
      </MotionWrapper>
    );
  }

  return (
    <MotionWrapper>
      <div className="video-call-container">
        {/* Header */}
        <div className="call-header">
          <div className="call-info">
            <div className="appointment-id">#{consultationInfo.appointmentId}</div>
            <div className="call-status">
              <span className={`status-indicator ${callStatus}`}></span>
              {callStatus === 'connecting' ? '‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...' : '‡§ï‡§®‡•á‡§ï‡•ç‡§ü‡•á‡§°'}
            </div>
            <div className="call-duration">{formatDuration(callDuration)}</div>
          </div>
          <div className="connection-quality">
            <span className="connection-icon">{getConnectionIcon()}</span>
            <span className="connection-text">{connectionQuality}</span>
          </div>
        </div>

        {/* Main Call Interface */}
        <div className="call-main">
          {/* Video Section */}
          <div className="video-section">
            {/* Remote Video (Doctor) */}
            <div className="remote-video-container">
              <video
                ref={remoteVideoRef}
                autoPlay
                playsInline
                className="remote-video"
              />
              <div className="video-overlay doctor-overlay">
                <div className="doctor-info">
                  <span className="doctor-name">{selectedDoctor?.name}</span>
                  <span className="doctor-specialization">{selectedDoctor?.specialization}</span>
                </div>
                <div className="video-controls-overlay">
                  <button className="overlay-btn" onClick={() => setIsVideoOn(!isVideoOn)}>
                    {isVideoOn ? 'üìπ' : 'üìπ'}
                  </button>
                  <button className="overlay-btn" onClick={() => setIsAudioOn(!isAudioOn)}>
                    {isAudioOn ? 'üîä' : 'üîá'}
                  </button>
                </div>
              </div>
            </div>

            {/* Local Video (Patient) */}
            <div className="local-video-container">
              <video
                ref={localVideoRef}
                autoPlay
                playsInline
                muted
                className={`local-video ${!isVideoOn ? 'video-off' : ''}`}
              />
              <div className="video-overlay patient-overlay">
                <span className="patient-name">{consultationInfo.patientName}</span>
                {!isVideoOn && <div className="video-off-indicator">üìπ</div>}
                {!isAudioOn && <div className="audio-off-indicator">üîá</div>}
              </div>
            </div>
          </div>

          {/* Side Panel */}
          <div className="side-panel">
            {/* Patient Info */}
            <div className="patient-info-card">
              <h3>‡§Æ‡§∞‡•Ä‡§ú‡§º ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä</h3>
              <div className="info-item">
                <span className="label">‡§®‡§æ‡§Æ:</span>
                <span className="value">{consultationInfo.patientName}</span>
              </div>
              <div className="info-item">
                <span className="label">‡§∏‡§Æ‡§Ø:</span>
                <span className="value">{consultationInfo.scheduledTime}</span>
              </div>
              <div className="info-item">
                <span className="label">‡§™‡•ç‡§∞‡§ï‡§æ‡§∞:</span>
                <span className="value">{consultationInfo.consultationType}</span>
              </div>
              <div className="info-item">
                <span className="label">‡§≤‡§ï‡•ç‡§∑‡§£:</span>
                <div className="symptoms-list">
                  {consultationInfo.symptoms.map((symptom, index) => (
                    <span key={index} className="symptom-tag">{symptom}</span>
                  ))}
                </div>
              </div>
            </div>

            {/* Chat Section */}
            <div className="chat-section">
              <div className="chat-header">
                <h3>‡§ö‡•à‡§ü</h3>
                <button 
                  className="notes-toggle"
                  onClick={() => setShowNotes(!showNotes)}
                >
                  üìù
                </button>
              </div>
              
              {!showNotes ? (
                <>
                  <div className="chat-messages" ref={chatScrollRef}>
                    {chatMessages.map((message) => (
                      <div key={message.id} className={`message ${message.type}`}>
                        {message.type === 'system' ? (
                          <div className="system-message">
                            <span className="system-text">{message.text}</span>
                            <span className="timestamp">{message.timestamp}</span>
                          </div>
                        ) : (
                          <div className="chat-message">
                            <div className="message-header">
                              <span className="sender">{message.sender}</span>
                              <span className="timestamp">{message.timestamp}</span>
                            </div>
                            <div className="message-text">{message.text}</div>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                  
                  <div className="chat-input">
                    <input
                      type="text"
                      value={newMessage}
                      onChange={(e) => setNewMessage(e.target.value)}
                      placeholder="‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç..."
                      onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                    />
                    <button onClick={sendMessage} className="send-btn">
                      üì§
                    </button>
                  </div>
                </>
              ) : (
                <div className="notes-section">
                  <h4>‡§™‡§∞‡§æ‡§Æ‡§∞‡•ç‡§∂ ‡§®‡•ã‡§ü‡•ç‡§∏</h4>
                  <textarea
                    value={consultationNotes}
                    onChange={(e) => setConsultationNotes(e.target.value)}
                    placeholder="‡§°‡•â‡§ï‡•ç‡§ü‡§∞ ‡§ï‡•á ‡§®‡•ã‡§ü‡•ç‡§∏ ‡§Ø‡§π‡§æ‡§Å ‡§¶‡§ø‡§ñ‡•á‡§Ç‡§ó‡•á..."
                    rows="10"
                  />
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Call Controls */}
        <div className="call-controls">
          <div className="control-group primary-controls">
            <button 
              className={`control-btn ${!isAudioOn ? 'disabled' : ''}`}
              onClick={toggleAudio}
              title={isAudioOn ? '‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç' : '‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç'}
            >
              {isAudioOn ? 'üé§' : 'üîá'}
            </button>
            
            <button 
              className={`control-btn ${!isVideoOn ? 'disabled' : ''}`}
              onClick={toggleVideo}
              title={isVideoOn ? '‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç' : '‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡•á‡§Ç'}
            >
              {isVideoOn ? 'üìπ' : 'üìπ'}
            </button>
            
            <button 
              className="control-btn end-call"
              onClick={endCall}
              title="‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç"
            >
              üìû
            </button>
          </div>
          
          <div className="control-group secondary-controls">
            <button 
              className={`control-btn ${isScreenSharing ? 'active' : ''}`}
              onClick={toggleScreenShare}
              title="‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§® ‡§∂‡•á‡§Ø‡§∞ ‡§ï‡§∞‡•á‡§Ç"
            >
              üñ•Ô∏è
            </button>
            
            <button 
              className="control-btn"
              onClick={() => setShowNotes(!showNotes)}
              title="‡§®‡•ã‡§ü‡•ç‡§∏"
            >
              üìù
            </button>
            
            <button 
              className="control-btn"
              title="‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏"
            >
              ‚öôÔ∏è
            </button>
          </div>
        </div>

        {/* End Call Confirmation Modal */}
        {showEndConfirm && (
          <div className="modal-overlay">
            <div className="end-call-modal">
              <h3>‡§ï‡•â‡§≤ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç?</h3>
              <p>‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§µ‡§æ‡§ï‡§à ‡§™‡§∞‡§æ‡§Æ‡§∞‡•ç‡§∂ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</p>
              <div className="modal-actions">
                <button 
                  className="cancel-btn"
                  onClick={() => setShowEndConfirm(false)}
                >
                  ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡•á‡§Ç
                </button>
                <button 
                  className="confirm-btn"
                  onClick={confirmEndCall}
                >
                  ‡§π‡§æ‡§Å, ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </MotionWrapper>
  );
};

export default VideoCall;